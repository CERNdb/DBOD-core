#!/usr/bin/env perl
# Copyright (C) 2018, CERN
# This software is distributed under the terms of the GNU General Public
# Licence version 3 (GPL Version 3), copied verbatim in the file "LICENSE".
# In applying this license, CERN does not waive the privileges and immunities
# granted to it by virtue of its status as Intergovernmental Organization
# or submit itself to any jurisdiction.

# Extension of the base DBOD::Job class to add extra required parameters

package DBOD::CheckConfig;

use Moose;
use DBOD;
use DBOD::Templates;
use DBOD::Network::Api;
use Data::Dumper;

extends 'DBOD::Job';
with 'MooseX::Getopt::Usage',
     'MooseX::Getopt::Usage::Role::Man';
 
use strict;

use DBOD::Job;
use Data::Dumper;

use DBOD qw ($ERROR $OK $db_type);
use DBOD::Instance;

$ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}= 0 ;

has 'file' => (
    is => 'ro', 
    isa => 'Str',
    required => $TRUE,
    documentation => qq{Path to config file} );

has 'update' => (
    is => 'ro', 
    isa => 'Bool',
    default => $FALSE,
    documentation => qq{Update file} );

# Main package
package main;

use strict;
use warnings;
        
use JSON;

use Log::Log4perl;
use Data::Dumper;
use DBOD;
use DBOD::Runtime;

my $job = DBOD::CheckConfig->new_with_options();

sub config_parser {

    # Parses a key=value configuration file and stores its contents as a hash{key:value}.
    # Expects a path to the file
    # Valid for MySQL, PostgreSQL (my.cnf, posgresql.conf)

    my $filename = shift;
    my (%hash);
    $job->log->debug("Loading configuration file: $filename");

    # Opens, read and closes file
    open FILE, "<$filename" or die "Can't open file $filename!";
    my @lines = <FILE>;
    close FILE;

    foreach (@lines) {
        next if /^#/ or /^(\s)*$/ or /^\s+#/;
        chomp;
        s/(\s)+#(.)+//; # Removes in-line comments like this one
        if (/.*=.*/) {
            my ($k,$v) = split(/\s*=\s*/, $_);
            $hash{$k} = $v;
        }
        else{
            $hash{$_} = 'on'; # For MySQL boolean parameters which can be enabled just by name
        }
    }
    return \%hash;
}

sub check_config {

    # Compares the configuration parameters from the user submited file and the currently
    # installed one.
    # If a parameter is listed in the @vetoed_parameters array and the user tries to modify it,
    # an error is returned (a boolean true value).

	$job->log->debug(Dumper \@_);
    my ($new_conf, $old_conf, $vetoed_parameters) = @_;

    my %new_config = %{config_parser($new_conf)};
	$job->log->debug(Dumper \%new_config);
    my %old_config = %{config_parser($old_conf)};
	$job->log->debug(Dumper \%old_config);

    # This converts the list list of vetoed parameters to hash, facilitating the use of
    # esxists in the conditional tests (easy way of checking for every key if they are
    # present in the list)

    my %vetoed_keys = map {$_ => 1} @{$vetoed_parameters};
    my $error = undef;

    my @infractions = ();

    foreach my $key (keys (%new_config)) {
        $job->log->debug("GeneralDBOD::check_config: Comparing key: $key, new: "
            . $new_config{$key} . " old: " . $old_config{$key});
        # If the key exists in %vetoed_keys and the user attemps to set a new value different from
        # the one in the current configuration file, an error is raised
        if ((exists $vetoed_keys{$key}) && ($new_config{$key} ne $old_config{$key})) {
            $job->log->debug("GeneralDBOD::check_config: ERROR: Atempting to set forbidden parameter $key");
            push @infractions, $key;
        }
    }

    if ($#infractions == -1) {return undef}
    else {return \@infractions};
}

sub body {

    my $instance = DBOD::Instance::Factory->create(
        $db_type->{$job->metadata->{db_type}},
        instance => $job->entity(),
        metadata => $job->metadata(),
        config => $job->config());
    
    if ($job->is_local()) {
        $job->log->debug('Job running locally in database host');
    } else {
        $job->log->debug('This job needs to be run locally');
       
        my $config_type = lc $job->metadata->{db_type};
        my $vetoed_parameters = $job->config->{$config_type}->{vetoed_parameters};
        my $old_config_file;
        if ($config_type eq "mysql") { $old_config_file = "my.cnf"; }
        elsif ($config_type eq "pg") { $old_config_file = "postgresql.conf"; }
        elsif ($config_type eq "influxdb") { $old_config_file = "influxdb.conf"; }
        
        my $infractions = check_config($job->{file}, 
            $job->metadata->{datadir} . '/' . $old_config_file, 
            $vetoed_parameters);
        
        if ($infractions) {
            my %response = ('infractions' => $infractions);
            $job->log->error("Infractions found: " . encode_json \%response);
            print encode_json \%response;
            return $ERROR;
        }
    }

    return $OK;
}

$job->run(\&body);

